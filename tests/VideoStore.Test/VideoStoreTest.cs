using System.Runtime.InteropServices;
using Xunit;

namespace VideoStore.Test
{
    public class VideoStoreTest
    {
        [Fact]
        public void ApproveCustomerStatement()
        {
            /*
                1. Use the code in a test harness by creating an instance of the Customer class and calling the 
                    statement method on that instance.
                2. Deal with the irritating dependency by using either the "Wrap and Extend" or 
                    "Subclass to Test" technique.
                3. Verify the result using Approvals.verify.
                4. Examine the file generated by Approvals and rename the suffix from *.received.txt 
                    to *.approved.txt. Re-run the test to make sure it is now green.
                5. Extract your test logic into a method that returns the result you are verifying.
                6. Examine the method under test (Customer::statement). What data does the method use? 
                    Extract that data as parameters to the method you created in the previous step.
                7. Convert your Approvals.verify test into a CombinationApprovals.verifyAllCombinations 
                    but start with only a single combination. Each parameter now becomes an array with a single item.
                8. Run the test, inspect the output, and approve the result.
                9. Run your test with code coverage and check for branches missing coverage. 
                    Add more combinations until all branches of the code are fully covered.
                10. Test mutations by finding places in the production code to modify. Do your tests 
                    fail when you break the production code? If they do not fail, the tests are not yet sufficient.
                11. Update tests to prevent mutation failures.
             */
        }
    }
}